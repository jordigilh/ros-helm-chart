# OpenShift-specific values for Cost Management On-Premise deployment
# This file provides OpenShift-specific overrides with testing/development settings
# Uses OpenShift Routes, ODF storage, and smaller resource allocations for testing
#
# OPTIMIZATION: This file reduces Helm lookup API calls from 29 to ~9 by providing
# explicit values for auto-detection. This improves deployment speed and reduces
# API server load, especially important in CI environments.
#
# For production deployments, override with larger values:
#   --set database.ros.storage.size=100Gi
#   --set resources.kruize.requests.memory=2Gi

global:
  # Cluster domain - auto-detected if empty, but providing it skips 4 API lookups
  # CI script will set this dynamically: $(oc get ingresses.config.openshift.io cluster -o jsonpath='{.spec.domain}')
  clusterDomain: ""  # Set by CI or leave empty for auto-detection
  
  # Cluster name - auto-detected if empty, but providing it skips 2 API lookups
  clusterName: ""  # Set by CI or leave empty for auto-detection
  
  # OpenShift Data Foundation (ODF) storage class
  # Common values: odf-storagecluster-ceph-rbd, ocs-storagecluster-ceph-rbd
  # When left empty, the cost-onprem.storage.class helper will auto-discover the default storage class from the cluster
  # Recommended: Leave empty for automatic detection
  storageClass: ""
  # Storage type for platform detection (odf for OpenShift, minio for Kubernetes)
  storageType: "odf"
  pullPolicy: IfNotPresent
  imagePullSecrets: []

# Explicit storage class names to avoid API lookups (optional but recommended for CI)
# When provided, skips StorageClass list/get API calls (saves 2-4 lookups)
# storageClassNames:
#   database: "odf-storagecluster-ceph-rbd"
#   kafka: "odf-storagecluster-ceph-rbd"
#   storage: "odf-storagecluster-ceph-rbd"
#   valkey: "odf-storagecluster-ceph-rbd"

# Reduced resource requirements for testing environment
# Production recommendation: Increase memory for Kruize (2-4Gi)
resources:
  application:
    requests:
      memory: "512Mi"
      cpu: "200m"
    limits:
      memory: "1Gi"
      cpu: "500m"

  kruize:
    requests:
      memory: "1Gi"
      cpu: "200m"
    limits:
      memory: "2Gi"
      cpu: "1000m"

# Use smaller storage sizes for testing
# Production recommendation: 100Gi for ros/kruize, 50Gi for sources
database:
  ros:
    storage:
      size: "5Gi"

  kruize:
    storage:
      size: "5Gi"

  sources:
    storage:
      size: "5Gi"

# Kafka configuration
# IMPORTANT: Kafka/Strimzi deployment is NOT managed by this Helm chart!
# The install-helm-chart.sh script installs Strimzi operator and creates Kafka cluster separately
# This section only contains connection settings for the deployed application
kafka:
  # Bootstrap servers for Kafka cluster (auto-configured by script)
  bootstrapServers: "cost-onprem-kafka-kafka-bootstrap.kafka.svc.cluster.local:9092"
  securityProtocol: "PLAINTEXT"

# Valkey (Production Cache - for OpenShift deployments)
# Replaces Redis on OpenShift
valkey:
  image:
    repository: registry.redhat.io/rhel10/valkey-8
    tag: "latest"
  bindAddress: "0.0.0.0"
  maxMemory: 512mb
  maxMemoryPolicy: allkeys-lru

# ODF (Production Storage - for OpenShift deployments)
# Replaces MinIO on OpenShift
# 
# OPTIMIZATION: Auto-detection makes 5-6 API lookups to discover NooBaa credentials
# For CI/testing, provide explicit credentials to skip lookups:
# odf:
#   credentials:
#     accessKey: "access-key-from-noobaa-admin-secret"
#     secretKey: "secret-key-from-noobaa-admin-secret"
#
# Production: Pre-create storage credentials Secret to skip all lookups:
#   kubectl create secret generic cost-onprem-storage-credentials \
#     --from-literal=AWS_ACCESS_KEY_ID=... \
#     --from-literal=AWS_SECRET_ACCESS_KEY=...
odf:
  endpoint: ""  # Auto-detected from NooBaa CRD status
  port: 443
  useSSL: true
  bucket: "ros-data"

# Kruize OpenShift-specific configuration
kruize:
  env:
    k8sType: openshift  # Override default kubernetes value

# JWT Authentication configuration (avoids Keycloak auto-discovery lookups)
# Providing explicit Keycloak settings saves ~8 API lookups
# CI script will set this dynamically: $(oc get route -n keycloak keycloak -o jsonpath='{.spec.host}')
jwtAuth:
  keycloak:
    # url: ""  # Set by CI script, e.g., "https://keycloak.apps.example.com"
    installed: true  # Tells chart Keycloak exists, skips CR lookup
    # namespace: "keycloak"  # Optional: skip namespace discovery
    # serviceName: "keycloak"  # Optional: skip service discovery

# Authentication configuration
# OpenShift uses native OAuth/RBAC, so we disable custom JWT auth
ingress:
  auth:
    enabled: false  # Use OpenShift native authentication
  upload:
    requireAuth: false  # Authentication handled by OpenShift Routes

# OpenShift Routes configuration (automatically used when deploying to OpenShift)
serviceRoute:
  enabled: true
  annotations:
    # OpenShift-specific route annotations
    haproxy.router.openshift.io/timeout: "300s"
    haproxy.router.openshift.io/rewrite-target: ""
  hosts:
    - host: ""  # Empty host uses cluster's default route domain
      paths:
        - path: /
          pathType: Prefix
  tls:
    # Uncomment to enable TLS termination
    # termination: edge
    # insecureEdgeTerminationPolicy: Redirect