# OpenShift-specific values for Cost Management On-Premise deployment
# This file provides OpenShift-specific overrides with testing/development settings
# Uses OpenShift Routes, ODF storage, and smaller resource allocations for testing
#
# OPTIMIZATION: This file reduces Helm lookup API calls from 29 to ~9 by providing
# explicit values for auto-detection. This improves deployment speed and reduces
# API server load, especially important in CI environments.
#
# For production deployments, override with larger values:
#   --set database.ros.storage.size=100Gi
#   --set resources.kruize.requests.memory=2Gi

global:
  # Cluster domain - auto-detected if empty, but providing it skips 4 API lookups
  # CI script will set this dynamically: $(oc get ingresses.config.openshift.io cluster -o jsonpath='{.spec.domain}')
  clusterDomain: ""  # Set by CI or leave empty for auto-detection

  # Cluster name - auto-detected if empty, but providing it skips 2 API lookups
  clusterName: ""  # Set by CI or leave empty for auto-detection

  # OpenShift Data Foundation (ODF) storage class
  # Common values: odf-storagecluster-ceph-rbd, ocs-storagecluster-ceph-rbd
  # When left empty, the cost-onprem.storage.class helper will auto-discover the default storage class from the cluster
  # Recommended: Leave empty for automatic detection
  storageClass: ""
  # Storage type for platform detection (odf for OpenShift, minio for Kubernetes)
  storageType: "odf"
  pullPolicy: IfNotPresent
  imagePullSecrets: []

# Explicit storage class names to avoid API lookups (optional but recommended for CI)
# When provided, skips StorageClass list/get API calls (saves 2-4 lookups)
# storageClassNames:
#   database: "odf-storagecluster-ceph-rbd"
#   kafka: "odf-storagecluster-ceph-rbd"
#   storage: "odf-storagecluster-ceph-rbd"
#   valkey: "odf-storagecluster-ceph-rbd"

# Reduced resource requirements for testing environment
# Production recommendation: Increase memory for Kruize (2-4Gi)
resources:
  application:
    requests:
      memory: "512Mi"
      cpu: "200m"
    limits:
      memory: "1Gi"
      cpu: "500m"

  kruize:
    requests:
      memory: "1Gi"
      cpu: "200m"
    limits:
      memory: "2Gi"
      cpu: "1000m"

# Use smaller storage sizes for testing
# Production recommendation: 100Gi for ros/kruize, 50Gi for sources
database:
  ros:
    storage:
      size: "5Gi"

  kruize:
    storage:
      size: "5Gi"

  sources:
    storage:
      size: "5Gi"

# Kafka configuration
# IMPORTANT: Kafka/Strimzi deployment is NOT managed by this Helm chart!
# The install-helm-chart.sh script installs Strimzi operator and creates Kafka cluster separately
# This section only contains connection settings for the deployed application
kafka:
  # Bootstrap servers for Kafka cluster (auto-configured by script)
  bootstrapServers: "cost-onprem-kafka-kafka-bootstrap.kafka.svc.cluster.local:9092"
  securityProtocol: "PLAINTEXT"

# Valkey (Production Cache - for OpenShift deployments)
# Replaces Redis on OpenShift
valkey:
  image:
    repository: registry.redhat.io/rhel10/valkey-8
    tag: "latest"
  bindAddress: "0.0.0.0"
  maxMemory: 512mb
  maxMemoryPolicy: allkeys-lru

# ODF (Production Storage - for OpenShift deployments)
# Replaces MinIO on OpenShift
#
# RECOMMENDED APPROACH: Direct Ceph RGW (Required for Cost Management)
# -----------------------------------------------------------------------
# Cost Management requires strong read-after-write consistency for S3.
# NooBaa's eventual consistency causes 403 errors when reading immediately after write.
# Direct Ceph RGW provides strong consistency and is the REQUIRED storage backend.
#
# To use Direct Ceph RGW (RECOMMENDED):
# 1. Create an ObjectBucketClaim BEFORE running the install script:
#
#    kubectl apply -f - <<EOF
#    apiVersion: objectbucket.io/v1alpha1
#    kind: ObjectBucketClaim
#    metadata:
#      name: ros-data-ceph
#      namespace: cost-onprem
#    spec:
#      generateBucketName: ros-data-ceph
#      storageClassName: ocs-storagecluster-ceph-rgw
#    EOF
#
# 2. The install script will auto-detect the OBC and:
#    - Extract bucket name, endpoint, and credentials
#    - Configure all components to use Direct Ceph RGW
#    - Skip the bucket creation job (bucket managed by OBC)
#
# FALLBACK: NooBaa (NOT RECOMMENDED for Cost Management)
# -------------------------------------------------------
# If no external OBC is detected, the chart falls back to NooBaa auto-detection.
# WARNING: NooBaa's eventual consistency may cause data processing failures.
#
odf:
  endpoint: ""  # Auto-detected: Ceph RGW (if OBC exists) or NooBaa (fallback)
  port: 443
  useSSL: true
  bucket: "ros-data"  # Only used for NooBaa fallback

  # External ObjectBucketClaim (OBC) configuration
  # Set to true when using pre-created OBC for Direct Ceph RGW
  # The install script auto-detects OBC named "ros-data-ceph" and sets this automatically
  useExternalOBC: false  # Auto-set to true by install script when OBC is detected

# Kruize OpenShift-specific configuration
kruize:
  env:
    k8sType: openshift  # Override default kubernetes value

# JWT Authentication configuration (avoids Keycloak auto-discovery lookups)
# Providing explicit Keycloak settings saves ~8 API lookups
# CI script will set this dynamically: $(oc get route -n keycloak keycloak -o jsonpath='{.spec.host}')
jwtAuth:
  keycloak:
    # url: ""  # Set by CI script, e.g., "https://keycloak.apps.example.com"
    installed: true  # Tells chart Keycloak exists, skips CR lookup
    # namespace: "keycloak"  # Optional: skip namespace discovery
    # serviceName: "keycloak"  # Optional: skip service discovery

# Authentication configuration
# OpenShift uses native OAuth/RBAC, so we disable custom JWT auth
ingress:
  auth:
    enabled: false  # Use OpenShift native authentication
  upload:
    requireAuth: false  # Authentication handled by OpenShift Routes

# OpenShift Routes configuration (automatically used when deploying to OpenShift)
serviceRoute:
  enabled: true
  annotations:
    # OpenShift-specific route annotations
    haproxy.router.openshift.io/timeout: "300s"
    haproxy.router.openshift.io/rewrite-target: ""
  hosts:
    - host: ""  # Empty host uses cluster's default route domain
      paths:
        - path: /
          pathType: Prefix
  tls:
    # Uncomment to enable TLS termination
    # termination: edge
    # insecureEdgeTerminationPolicy: Redirect