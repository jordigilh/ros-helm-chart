#!/bin/bash

# Red Hat Build of Keycloak (RHBK) Deployment Script for OpenShift
# This script automates the deployment of RHBK with all necessary configurations
# for JWT authentication with the Cost Management Metrics Operator
#
# RHBK uses the Keycloak Operator API: k8s.keycloak.org/v2alpha1
#
# Environment Variables:
#   LOG_LEVEL - Control output verbosity (ERROR|WARN|INFO|DEBUG, default: WARN)
#
# Examples:
#   # Default (clean output)
#   ./deploy-rhbk.sh
#
#   # Detailed output
#   LOG_LEVEL=INFO ./deploy-rhbk.sh
#
#   # Quiet (errors only)
#   LOG_LEVEL=ERROR ./deploy-rhbk.sh

set -e  # Exit on any error

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging configuration
LOG_LEVEL=${LOG_LEVEL:-WARN}

# Configuration
NAMESPACE=${RHBK_NAMESPACE:-keycloak}
STORAGE_CLASS=${STORAGE_CLASS:-}  # Auto-detect if empty
# Note: Admin credentials are auto-generated by RHBK operator (keycloak-initial-admin secret)
REALM_NAME=${REALM_NAME:-kubernetes}
COST_MGMT_OPERATOR_CLIENT_ID=${COST_MGMT_OPERATOR_CLIENT_ID:-cost-management-operator}
COST_MGMT_UI_CLIENT_ID=${COST_MGMT_UI_CLIENT_ID:-cost-management-ui}
COST_MGMT_NAMESPACE=${COST_MGMT_NAMESPACE:-cost-onprem}
COST_MGMT_RELEASE_NAME=${COST_MGMT_RELEASE_NAME:-cost-onprem}
KEYCLOAK_INSTANCES=${KEYCLOAK_INSTANCES:-1}

# OpenShift cluster-specific configuration (auto-detected)
CLUSTER_DOMAIN=""
OAUTH_CALLBACK=""
CONSOLE_URL=""
UI_BASE_URL=${COST_MGMT_UI_BASE_URL:-}  # Can be set via COST_MGMT_UI_BASE_URL, otherwise auto-detected

# Logging functions with level-based filtering
log_debug() {
    [[ "$LOG_LEVEL" == "DEBUG" ]] && echo -e "${BLUE}[DEBUG]${NC} $1"
    return 0
}

log_info() {
    [[ "$LOG_LEVEL" =~ ^(INFO|DEBUG)$ ]] && echo -e "${BLUE}[INFO]${NC} $1"
    return 0
}

log_success() {
    [[ "$LOG_LEVEL" =~ ^(WARN|INFO|DEBUG)$ ]] && echo -e "${GREEN}[SUCCESS]${NC} $1"
    return 0
}

log_warning() {
    [[ "$LOG_LEVEL" =~ ^(WARN|INFO|DEBUG)$ ]] && echo -e "${YELLOW}[WARNING]${NC} $1"
    return 0
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    return 0
}

log_header() {
    [[ "$LOG_LEVEL" =~ ^(WARN|INFO|DEBUG)$ ]] && {
        echo ""
        echo -e "${BLUE}============================================${NC}"
        echo -e "${BLUE} $1${NC}"
        echo -e "${BLUE}============================================${NC}"
        echo ""
    }
    return 0
    return 0
}

# Backward compatibility aliases
echo_info() { log_info "$1"; }
echo_success() { log_success "$1"; }
echo_warning() { log_warning "$1"; }
echo_error() { log_error "$1"; }
echo_header() { log_header "$1"; }

# Function to check prerequisites
check_prerequisites() {
    echo_header "CHECKING PREREQUISITES"

    # Check if oc command is available
    if ! command -v oc >/dev/null 2>&1; then
        echo_error "oc command not found. Please install OpenShift CLI."
        exit 1
    fi
    echo_success "✓ OpenShift CLI (oc) is available"

    # Check if logged into OpenShift/Kubernetes
    # Use kubectl cluster-info as it works with both oc and kubectl
    if ! kubectl cluster-info >/dev/null 2>&1; then
        echo_error "Not logged into cluster. Please run 'oc login' or configure kubectl."
        exit 1
    fi
    CURRENT_CONTEXT=$(kubectl config current-context 2>/dev/null || echo "unknown")
    echo_success "✓ Logged into cluster (context: $CURRENT_CONTEXT)"

    # Check if cluster has admin permissions
    if ! kubectl auth can-i create subscriptions.operators.coreos.com -A >/dev/null 2>&1; then
        echo_error "Insufficient permissions to install operators. Cluster admin access required."
        exit 1
    fi
    echo_success "✓ Cluster admin permissions verified"

    # Auto-detect cluster domain
    CLUSTER_DOMAIN=$(kubectl get ingresses.config.openshift.io cluster -o jsonpath='{.spec.domain}' 2>/dev/null || echo "")
    if [ -n "$CLUSTER_DOMAIN" ]; then
        OAUTH_CALLBACK="https://oauth-openshift.apps.$CLUSTER_DOMAIN"
        CONSOLE_URL="https://console-openshift-console.apps.$CLUSTER_DOMAIN"
        echo_success "✓ Cluster domain detected: $CLUSTER_DOMAIN"

        # Auto-detect UI base URL if not explicitly set
        if [ -z "$UI_BASE_URL" ]; then
            # Try to detect from existing route
            local ui_route=$(oc get route -n "$COST_MGMT_NAMESPACE" -l app.kubernetes.io/component=ui -o jsonpath='{.items[0].spec.host}' 2>/dev/null || echo "")
            if [ -n "$ui_route" ]; then
                UI_BASE_URL="https://$ui_route"
                echo_success "✓ Auto-detected UI URL from existing route: $UI_BASE_URL"
            else
                # Construct expected URL pattern: {release-name}-ui-{namespace}.{clusterDomain}
                UI_BASE_URL="https://${COST_MGMT_RELEASE_NAME}-ui-${COST_MGMT_NAMESPACE}.${CLUSTER_DOMAIN}"
                echo_info "Using constructed UI URL: $UI_BASE_URL (set COST_MGMT_UI_BASE_URL to override)"
            fi
        else
            echo_success "✓ Using provided UI URL: $UI_BASE_URL"
        fi
    else
        echo_warning "Could not auto-detect cluster domain. OpenShift integration may need manual configuration."
        if [ -z "$UI_BASE_URL" ]; then
            echo_warning "UI URL not set. Please set COST_MGMT_UI_BASE_URL environment variable."
        fi
    fi

    # Auto-detect default storage class if not provided
    if [ -z "$STORAGE_CLASS" ]; then
        STORAGE_CLASS=$(oc get storageclass -o jsonpath='{.items[?(@.metadata.annotations.storageclass\.kubernetes\.io/is-default-class=="true")].metadata.name}' 2>/dev/null | awk '{print $1}')
        if [ -n "$STORAGE_CLASS" ]; then
            echo_success "✓ Auto-detected default storage class: $STORAGE_CLASS"
        else
            echo_error "No default storage class found. Available storage classes:"
            oc get storageclass --no-headers -o custom-columns=NAME:.metadata.name | sed 's/^/  - /' || true
            echo_error "Please set STORAGE_CLASS environment variable to specify a storage class."
            exit 1
        fi
    else
        # Check if user-provided storage class exists
        if oc get storageclass "$STORAGE_CLASS" >/dev/null 2>&1; then
            echo_success "✓ Storage class '$STORAGE_CLASS' is available"
        else
            echo_error "Storage class '$STORAGE_CLASS' not found. Available storage classes:"
            oc get storageclass --no-headers -o custom-columns=NAME:.metadata.name | sed 's/^/  - /' || true
            echo_error "Please specify a valid storage class with STORAGE_CLASS environment variable."
            exit 1
        fi
    fi

    echo_success "Prerequisites check completed successfully"
}

# Function to create namespace
create_namespace() {
    echo_header "CREATING NAMESPACE"

    if oc get namespace "$NAMESPACE" >/dev/null 2>&1; then
        echo_warning "Namespace '$NAMESPACE' already exists"
    else
        echo_info "Creating namespace: $NAMESPACE"
        oc create namespace "$NAMESPACE"
        echo_success "✓ Namespace '$NAMESPACE' created"
    fi

    # Label namespace for monitoring and management
    oc label namespace "$NAMESPACE" app=sso --overwrite=true
    echo_success "✓ Namespace labeled with app=sso"
}

# Function to install RHBK operator
install_rhbk_operator() {
    echo_header "INSTALLING RED HAT BUILD OF KEYCLOAK OPERATOR"

    # Create OperatorGroup if it doesn't exist
    if ! oc get operatorgroup rhbk-operator-group -n "$NAMESPACE" >/dev/null 2>&1; then
        echo_info "Creating OperatorGroup..."
        cat <<EOF | oc apply -f -
apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: rhbk-operator-group
  namespace: $NAMESPACE
spec:
  targetNamespaces:
  - $NAMESPACE
EOF
        echo_success "✓ OperatorGroup created"
    else
        echo_success "✓ OperatorGroup already exists"
    fi

    # Check if operator is already installed
    if oc get subscription rhbk-operator -n "$NAMESPACE" >/dev/null 2>&1; then
        echo_warning "RHBK Operator subscription already exists"
    else
        echo_info "Creating RHBK Operator subscription..."

        cat <<EOF | oc apply -f -
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: rhbk-operator
  namespace: $NAMESPACE
spec:
  channel: stable-v22
  installPlanApproval: Automatic
  name: rhbk-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace
EOF
        echo_success "✓ RHBK Operator subscription created"
    fi

    # Wait for operator to be ready
    echo_info "Waiting for RHBK operator to be ready..."
    local timeout=300
    local elapsed=0

    while [ $elapsed -lt $timeout ]; do
        # RHBK operator deployment name is different
        if oc get deployment rhbk-operator -n "$NAMESPACE" >/dev/null 2>&1; then
            if oc get deployment rhbk-operator -n "$NAMESPACE" -o jsonpath='{.status.readyReplicas}' | grep -q "1"; then
                echo_success "✓ RHBK Operator is ready"
                return 0
            fi
        fi

        if [ $((elapsed % 30)) -eq 0 ]; then
            echo_info "Still waiting for RHBK operator... (${elapsed}s elapsed)"
        fi

        sleep 5
        elapsed=$((elapsed + 5))
    done

    echo_error "Timeout waiting for RHBK operator to be ready"
    exit 1
}

# Note: Admin credentials are auto-generated by RHBK operator
# The operator automatically creates keycloak-initial-admin secret when Keycloak instance is deployed
# No manual secret creation needed

# Function to deploy PostgreSQL database for Keycloak
deploy_postgresql() {
    echo_header "DEPLOYING POSTGRESQL DATABASE"

    # Create database secret
    if ! oc get secret keycloak-db-secret -n "$NAMESPACE" >/dev/null 2>&1; then
        echo_info "Creating database credentials secret..."
        cat <<EOF | oc apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: keycloak-db-secret
  namespace: $NAMESPACE
type: Opaque
stringData:
  username: keycloak
  password: keycloak
EOF
        echo_success "✓ Database credentials secret created"
    fi

    # Check if PostgreSQL Service already exists
    if ! oc get service postgres -n "$NAMESPACE" >/dev/null 2>&1; then
        echo_info "Creating PostgreSQL Service..."
        cat <<EOF | oc apply -f -
apiVersion: v1
kind: Service
metadata:
  name: postgres
  namespace: $NAMESPACE
  labels:
    app: keycloak-db
    component: database
spec:
  ports:
    - name: postgres
      port: 5432
      targetPort: 5432
      protocol: TCP
  selector:
    app: keycloak-db
    component: database
  clusterIP: None
EOF
        echo_success "✓ PostgreSQL Service created"
    fi

    # Check if PostgreSQL StatefulSet already exists
    if oc get statefulset keycloak-db -n "$NAMESPACE" >/dev/null 2>&1; then
        echo_warning "PostgreSQL StatefulSet already exists"
    else
        echo_info "Creating PostgreSQL StatefulSet..."
        cat <<EOF | oc apply -f -
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: keycloak-db
  namespace: $NAMESPACE
  labels:
    app: keycloak-db
    component: database
spec:
  serviceName: postgres
  replicas: 1
  selector:
    matchLabels:
      app: keycloak-db
      component: database
  template:
    metadata:
      labels:
        app: keycloak-db
        component: database
    spec:
      containers:
        - name: postgres
          image: registry.redhat.io/rhel9/postgresql-15:latest
          imagePullPolicy: IfNotPresent
          ports:
            - name: postgres
              containerPort: 5432
              protocol: TCP
          env:
            - name: POSTGRESQL_DATABASE
              value: keycloak
            - name: POSTGRESQL_USER
              valueFrom:
                secretKeyRef:
                  name: keycloak-db-secret
                  key: username
            - name: POSTGRESQL_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak-db-secret
                  key: password
            - name: PGDATA
              value: "/var/lib/pgsql/data/pgdata"
          volumeMounts:
            - name: postgres-storage
              mountPath: /var/lib/pgsql/data
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - pg_isready -U \$POSTGRESQL_USER -d \$POSTGRESQL_DATABASE
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 6
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - pg_isready -U \$POSTGRESQL_USER -d \$POSTGRESQL_DATABASE
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 6
          resources:
            requests:
              cpu: 250m
              memory: 512Mi
            limits:
              cpu: 1000m
              memory: 1Gi
  volumeClaimTemplates:
    - metadata:
        name: postgres-storage
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: $STORAGE_CLASS
        resources:
          requests:
            storage: 10Gi
EOF
        echo_success "✓ PostgreSQL StatefulSet created"
    fi

    # Wait for PostgreSQL to be ready
    echo_info "Waiting for PostgreSQL to be ready..."
    oc wait --for=condition=ready pod -l app=keycloak-db -n "$NAMESPACE" --timeout=300s || {
        echo_warning "PostgreSQL pod not ready yet, continuing anyway..."
    }

    echo_success "✓ PostgreSQL deployment complete"
}

# Function to deploy Keycloak instance
deploy_keycloak() {
    echo_header "DEPLOYING KEYCLOAK INSTANCE (RHBK v22+)"

    # Detect the OpenShift apps domain for the route hostname
    local CLUSTER_DOMAIN=$(oc get ingresses.config.openshift.io cluster -o jsonpath='{.spec.domain}' 2>/dev/null)
    if [ -z "$CLUSTER_DOMAIN" ]; then
        echo_error "Could not detect OpenShift cluster domain"
        exit 1
    fi

    local KEYCLOAK_HOSTNAME="keycloak-${NAMESPACE}.${CLUSTER_DOMAIN}"
    echo_info "Keycloak will be accessible at: https://$KEYCLOAK_HOSTNAME"

    # Check if Keycloak instance already exists
    if oc get keycloak keycloak -n "$NAMESPACE" >/dev/null 2>&1; then
        echo_warning "Keycloak instance 'keycloak' already exists"
    else
        echo_info "Creating Keycloak instance with v2alpha1 API..."

        cat <<EOF | oc apply -f -
apiVersion: k8s.keycloak.org/v2alpha1
kind: Keycloak
metadata:
  name: keycloak
  namespace: $NAMESPACE
  labels:
    app: sso
spec:
  instances: $KEYCLOAK_INSTANCES
  db:
    vendor: postgres
    host: postgres
    usernameSecret:
      name: keycloak-db-secret
      key: username
    passwordSecret:
      name: keycloak-db-secret
      key: password
  http:
    httpEnabled: true
  hostname:
    hostname: $KEYCLOAK_HOSTNAME
    admin: $KEYCLOAK_HOSTNAME
    strict: false
    strictBackchannel: false
  ingress:
    enabled: true
  unsupported:
    podTemplate:
      spec:
        containers:
        - name: keycloak
          env:
          - name: KC_PROXY
            value: edge
          resources:
            requests:
              cpu: 500m
              memory: 1Gi
            limits:
              cpu: 1000m
              memory: 2Gi
EOF
        echo_success "✓ Keycloak instance created"
    fi

    # Note: RHBK operator manages storage automatically
    # No need to manually create PVCs - the operator handles this

    # Create OpenShift Route for Keycloak
    if ! oc get route keycloak -n "$NAMESPACE" >/dev/null 2>&1; then
        echo_info "Creating OpenShift Route for Keycloak..."
        cat <<EOF | oc apply -f -
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: keycloak
  namespace: $NAMESPACE
  labels:
    app: keycloak
spec:
  to:
    kind: Service
    name: keycloak-service
    weight: 100
  port:
    targetPort: 8080
  tls:
    termination: edge
    insecureEdgeTerminationPolicy: Redirect
  wildcardPolicy: None
EOF
        echo_success "✓ Keycloak Route created"
    fi

    # Wait for Keycloak to be ready
    echo_info "Waiting for Keycloak to be ready (this may take several minutes)..."
    local timeout=600
    local elapsed=0

    while [ $elapsed -lt $timeout ]; do
        local status=$(oc get keycloak keycloak -n "$NAMESPACE" -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "False")
        if [ "$status" = "True" ]; then
            echo_success "✓ Keycloak CR is ready"

            # Display connection information
            local hostname=$(oc get keycloak keycloak -n "$NAMESPACE" -o jsonpath='{.status.hostname}' 2>/dev/null || echo "")

            if [ -n "$hostname" ]; then
                echo_info "Keycloak Hostname: https://$hostname"
            fi

            break
        fi

        if [ $((elapsed % 60)) -eq 0 ]; then
            echo_info "Still waiting for Keycloak CR... (${elapsed}s elapsed)"
        fi

        sleep 10
        elapsed=$((elapsed + 10))
    done

    if [ $elapsed -ge $timeout ]; then
        echo_error "Timeout waiting for Keycloak CR to be ready"
        exit 1
    fi

    # Now wait for Keycloak HTTP endpoint to be fully responsive
    echo_info "Waiting for Keycloak admin API to be fully responsive..."
    local KEYCLOAK_ROUTE_HOST=$(oc get route keycloak -n "$NAMESPACE" -o jsonpath='{.spec.host}' 2>/dev/null)

    if [ -z "$KEYCLOAK_ROUTE_HOST" ]; then
        echo_error "Could not find Keycloak route"
        exit 1
    fi

    local KEYCLOAK_URL="https://$KEYCLOAK_ROUTE_HOST"
    local http_timeout=300
    local http_elapsed=0
    local http_ready=false

    echo_info "Testing Keycloak admin API at: $KEYCLOAK_URL/realms/master/protocol/openid-connect/token"
    echo_info "This ensures the admin API is fully ready for client secret extraction"

    while [ $http_elapsed -lt $http_timeout ]; do
        # Test the token endpoint with a dummy request
        # Should return JSON (either {"error":"invalid_grant"} or a token)
        # NOT HTML or empty response
        local response=$(curl -sk --max-time 5 \
            -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=test-readiness-check" \
            -d "password=test" \
            -d "grant_type=password" \
            -d "client_id=admin-cli" 2>/dev/null || echo "")

        # Check if we got a valid JSON response (contains "error" or "access_token")
        if echo "$response" | grep -qE '("error"|"access_token")'; then
            echo_success "✓ Keycloak admin API is ready and responding with JSON"
            http_ready=true
            break
        fi

        # Check if we got HTML (Keycloak is starting but not ready)
        if echo "$response" | grep -qE '(<html|<body|<!DOCTYPE)'; then
            if [ $((http_elapsed % 30)) -eq 0 ] && [ $http_elapsed -gt 0 ]; then
                echo_info "Still waiting for admin API... (returning HTML, ${http_elapsed}s elapsed)"
            fi
        elif [ -z "$response" ]; then
            if [ $((http_elapsed % 30)) -eq 0 ] && [ $http_elapsed -gt 0 ]; then
                echo_info "Still waiting for admin API... (no response, ${http_elapsed}s elapsed)"
            fi
        else
            if [ $((http_elapsed % 30)) -eq 0 ] && [ $http_elapsed -gt 0 ]; then
                echo_info "Still waiting for admin API... (unexpected response, ${http_elapsed}s elapsed)"
            fi
        fi

        sleep 5
        http_elapsed=$((http_elapsed + 5))
    done

    if [ "$http_ready" = false ]; then
        echo_error "Timeout waiting for Keycloak admin API to be ready"
        echo_error "The Keycloak CR is ready but the admin API is not responding correctly"
        exit 1
    fi

    echo_success "✓ Keycloak is fully ready for client secret extraction"
}

# Function to create Kubernetes realm using KeycloakRealmImport
create_kubernetes_realm() {
    echo_header "CREATING KUBERNETES REALM (KeycloakRealmImport)"

    # Validate UI_BASE_URL is set
    if [ -z "$UI_BASE_URL" ]; then
        echo_warning "UI_BASE_URL is not set. UI client will be created with empty redirect URIs."
        echo_warning "Set COST_MGMT_UI_BASE_URL environment variable to configure UI client properly."
        UI_BASE_URL=""  # Use empty string for now
    fi

    # Check if realm import already exists
    if oc get keycloakrealmimport kubernetes-realm -n "$NAMESPACE" >/dev/null 2>&1; then
        echo_warning "KeycloakRealmImport 'kubernetes-realm' already exists"
    else
        echo_info "Creating Kubernetes realm via KeycloakRealmImport..."

        cat <<EOF | oc apply -f -
apiVersion: k8s.keycloak.org/v2alpha1
kind: KeycloakRealmImport
metadata:
  name: kubernetes-realm
  namespace: $NAMESPACE
  labels:
    app: sso
spec:
  keycloakCRName: keycloak
  realm:
    id: $REALM_NAME
    realm: $REALM_NAME
    enabled: true
    displayName: "Kubernetes Realm"
    accessTokenLifespan: 300
    bruteForceProtected: true
    failureFactor: 30
    maxDeltaTimeSeconds: 43200
    maxFailureWaitSeconds: 900
    registrationAllowed: false
    rememberMe: true
    resetPasswordAllowed: true
    verifyEmail: false
    clientScopes:
      - name: api.console
        description: "API Console access scope for cost management"
        protocol: openid-connect
        attributes:
          include.in.token.scope: "true"
          display.on.consent.screen: "false"
      - name: profile
        description: "OpenID Connect built-in scope: profile"
        protocol: openid-connect
        attributes:
          include.in.token.scope: "true"
          display.on.consent.screen: "true"
        protocolMappers:
          - name: username
            protocol: openid-connect
            protocolMapper: oidc-usermodel-property-mapper
            config:
              userinfo.token.claim: "true"
              user.attribute: username
              id.token.claim: "true"
              access.token.claim: "true"
              claim.name: preferred_username
              jsonType.label: String
          - name: given name
            protocol: openid-connect
            protocolMapper: oidc-usermodel-property-mapper
            config:
              userinfo.token.claim: "true"
              user.attribute: firstName
              id.token.claim: "true"
              access.token.claim: "true"
              claim.name: given_name
              jsonType.label: String
          - name: family name
            protocol: openid-connect
            protocolMapper: oidc-usermodel-property-mapper
            config:
              userinfo.token.claim: "true"
              user.attribute: lastName
              id.token.claim: "true"
              access.token.claim: "true"
              claim.name: family_name
              jsonType.label: String
          - name: full name
            protocol: openid-connect
            protocolMapper: oidc-full-name-mapper
            config:
              id.token.claim: "true"
              access.token.claim: "true"
              userinfo.token.claim: "true"
          - name: org_id
            protocol: openid-connect
            protocolMapper: oidc-usermodel-attribute-mapper
            config:
              userinfo.token.claim: "true"
              user.attribute: org_id
              id.token.claim: "true"
              access.token.claim: "true"
              claim.name: org_id
              jsonType.label: String
          - name: account_number
            protocol: openid-connect
            protocolMapper: oidc-usermodel-attribute-mapper
            config:
              userinfo.token.claim: "true"
              user.attribute: account_number
              id.token.claim: "true"
              access.token.claim: "true"
              claim.name: account_number
              jsonType.label: String
      - name: email
        description: "OpenID Connect built-in scope: email"
        protocol: openid-connect
        attributes:
          include.in.token.scope: "true"
          display.on.consent.screen: "true"
        protocolMappers:
          - name: email
            protocol: openid-connect
            protocolMapper: oidc-usermodel-property-mapper
            config:
              userinfo.token.claim: "true"
              user.attribute: email
              id.token.claim: "true"
              access.token.claim: "true"
              claim.name: email
              jsonType.label: String
          - name: email verified
            protocol: openid-connect
            protocolMapper: oidc-usermodel-property-mapper
            config:
              userinfo.token.claim: "true"
              user.attribute: emailVerified
              id.token.claim: "true"
              access.token.claim: "true"
              claim.name: email_verified
              jsonType.label: boolean
    defaultDefaultClientScopes:
      - api.console
      - profile
      - email
    clients:
      - clientId: $COST_MGMT_OPERATOR_CLIENT_ID
        name: "Cost Management Operator Service Account"
        description: "Service account client for Cost Management Metrics Operator"
        enabled: true
        clientAuthenticatorType: client-secret
        serviceAccountsEnabled: true
        standardFlowEnabled: false
        directAccessGrantsEnabled: false
        implicitFlowEnabled: false
        publicClient: false
        protocol: openid-connect
        defaultClientScopes:
          - openid
          - profile
          - email
          - api.console
        protocolMappers:
          - name: audience-mapper
            protocol: openid-connect
            protocolMapper: oidc-audience-mapper
            config:
              access.token.claim: "true"
              id.token.claim: "false"
              included.client.audience: $COST_MGMT_OPERATOR_CLIENT_ID
          - name: client-id-mapper
            protocol: openid-connect
            protocolMapper: oidc-usersessionmodel-note-mapper
            config:
              access.token.claim: "true"
              claim.name: clientId
              id.token.claim: "true"
              user.session.note: clientId
          - name: api-console-mock
            protocol: openid-connect
            protocolMapper: oidc-hardcoded-claim-mapper
            config:
              access.token.claim: "true"
              claim.name: scope
              claim.value: api.console
              id.token.claim: "false"
          - name: org-id-mapper
            protocol: openid-connect
            protocolMapper: oidc-hardcoded-claim-mapper
            config:
              access.token.claim: "true"
              claim.name: org_id
              claim.value: "org1234567"
              id.token.claim: "false"
              jsonType.label: String
              userinfo.token.claim: "false"
          - name: account-number-mapper
            protocol: openid-connect
            protocolMapper: oidc-hardcoded-claim-mapper
            config:
              access.token.claim: "true"
              claim.name: account_number
              claim.value: "7890123"
              id.token.claim: "false"
              jsonType.label: String
              userinfo.token.claim: "false"
      - clientId: $COST_MGMT_UI_CLIENT_ID
        name: "Cost Management UI"
        description: "OAuth2 client for Cost Management UI"
        enabled: true
        clientAuthenticatorType: client-secret
        serviceAccountsEnabled: false
        standardFlowEnabled: true
        directAccessGrantsEnabled: true
        implicitFlowEnabled: false
        publicClient: false
        protocol: openid-connect
        redirectUris:
          - "${UI_BASE_URL}/oauth2/callback"
        webOrigins:
          - "$UI_BASE_URL"
        defaultClientScopes:
          - api.console
          - profile
          - email
        optionalClientScopes:
          - offline_access
        protocolMappers:
          - name: aud-mapper-cost-management-ui
            protocol: openid-connect
            protocolMapper: oidc-audience-mapper
            config:
              included.client.audience: $COST_MGMT_UI_CLIENT_ID
              id.token.claim: "true"
              access.token.claim: "true"
          # Map user attributes to JWT claims for X-Rh-Identity construction
          - name: org-id-mapper
            protocol: openid-connect
            protocolMapper: oidc-usermodel-attribute-mapper
            config:
              user.attribute: org_id
              claim.name: org_id
              access.token.claim: "true"
              id.token.claim: "true"
              jsonType.label: String
              userinfo.token.claim: "false"
          - name: account-number-mapper
            protocol: openid-connect
            protocolMapper: oidc-usermodel-attribute-mapper
            config:
              user.attribute: account_number
              claim.name: account_number
              access.token.claim: "true"
              id.token.claim: "true"
              jsonType.label: String
              userinfo.token.claim: "false"
          # Note: "access" attribute mapper removed - using ENHANCED_ORG_ADMIN mode
          # All authenticated users are org admins with full access within their org
EOF
        echo_success "✓ Kubernetes realm import created"
    fi

    # Wait for realm import to complete
    echo_info "Waiting for realm import to complete..."
    local timeout=120
    local elapsed=0

    while [ $elapsed -lt $timeout ]; do
        local status=$(oc get keycloakrealmimport kubernetes-realm -n "$NAMESPACE" -o jsonpath='{.status.conditions[?(@.type=="Done")].status}' 2>/dev/null || echo "False")
        if [ "$status" = "True" ]; then
            echo_success "✓ Kubernetes realm import completed"
            break
        fi

        sleep 5
        elapsed=$((elapsed + 5))
    done

    if [ $elapsed -ge $timeout ]; then
        echo_error "Timeout waiting for realm import to complete"
        exit 1
    fi

    # Additional wait for Keycloak to fully process the realm and make clients available via admin API
    echo_info "Waiting for Keycloak to process realm and clients..."
    local KEYCLOAK_URL="https://$(oc get route keycloak -n "$NAMESPACE" -o jsonpath='{.spec.host}' 2>/dev/null)"
    local post_import_timeout=60
    local post_import_elapsed=0
    local clients_available=false

    # Get admin password for testing
    local ADMIN_PASSWORD=$(oc get secret keycloak-initial-admin -n "$NAMESPACE" -o jsonpath='{.data.password}' 2>/dev/null | base64 -d)

    while [ $post_import_elapsed -lt $post_import_timeout ]; do
        # Try to list clients in the realm - this will fail if realm is not fully processed
        local token_response=$(curl -sk -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=admin" \
            -d "password=$ADMIN_PASSWORD" \
            -d "grant_type=password" \
            -d "client_id=admin-cli" 2>/dev/null)

        local access_token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)

        if [ -n "$access_token" ]; then
            # Try to get the clients we just created
            local client_data=$(curl -sk -X GET "$KEYCLOAK_URL/admin/realms/$REALM_NAME/clients" \
                -H "Authorization: Bearer $access_token" 2>/dev/null)

            # Check if both clients are in the list
            local operator_client_found=false
            local ui_client_found=false

            if echo "$client_data" | grep -q "\"clientId\":\"$COST_MGMT_OPERATOR_CLIENT_ID\""; then
                echo_success "✓ Client '$COST_MGMT_OPERATOR_CLIENT_ID' is available via admin API"
                operator_client_found=true
            fi

            if echo "$client_data" | grep -q "\"clientId\":\"$COST_MGMT_UI_CLIENT_ID\""; then
                echo_success "✓ Client '$COST_MGMT_UI_CLIENT_ID' is available via admin API"
                ui_client_found=true
            fi

            if [ "$operator_client_found" = true ] && [ "$ui_client_found" = true ]; then
                clients_available=true
                break
            fi
        fi

        if [ $((post_import_elapsed % 15)) -eq 0 ] && [ $post_import_elapsed -gt 0 ]; then
            echo_info "Still waiting for clients to be available... (${post_import_elapsed}s elapsed)"
        fi

        sleep 5
        post_import_elapsed=$((post_import_elapsed + 5))
    done

    if [ "$clients_available" = false ]; then
        echo_warning "Clients not immediately available, but realm import completed"
        echo_info "Client secret extraction may need to retry"
    fi

    echo_success "✓ Realm import process complete"
}

# Note: Client secret extraction is handled by the extract_client_secret() function below
# which uses the Keycloak Admin API for secure retrieval

# Function to validate deployment
validate_deployment() {
    echo_header "VALIDATING DEPLOYMENT"

    local validation_errors=0

    # Check namespace
    if oc get namespace "$NAMESPACE" >/dev/null 2>&1; then
        echo_success "✓ Namespace '$NAMESPACE' exists"
    else
        echo_error "✗ Namespace '$NAMESPACE' not found"
        validation_errors=$((validation_errors + 1))
    fi

    # Check operator
    if oc get deployment rhbk-operator -n "$NAMESPACE" >/dev/null 2>&1; then
        local ready_replicas=$(oc get deployment rhbk-operator -n "$NAMESPACE" -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
        if [ "$ready_replicas" = "1" ]; then
            echo_success "✓ RHBK Operator is running"
        else
            echo_error "✗ RHBK Operator is not ready"
            validation_errors=$((validation_errors + 1))
        fi
    else
        echo_error "✗ RHBK Operator not found"
        validation_errors=$((validation_errors + 1))
    fi

    # Check Keycloak instance
    if oc get keycloak keycloak -n "$NAMESPACE" >/dev/null 2>&1; then
        local status=$(oc get keycloak keycloak -n "$NAMESPACE" -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "False")
        if [ "$status" = "True" ]; then
            echo_success "✓ Keycloak instance is ready"
        else
            echo_error "✗ Keycloak instance is not ready"
            validation_errors=$((validation_errors + 1))
        fi
    else
        echo_error "✗ Keycloak instance not found"
        validation_errors=$((validation_errors + 1))
    fi

    # Check realm import
    if oc get keycloakrealmimport kubernetes-realm -n "$NAMESPACE" >/dev/null 2>&1; then
        local status=$(oc get keycloakrealmimport kubernetes-realm -n "$NAMESPACE" -o jsonpath='{.status.conditions[?(@.type=="Done")].status}' 2>/dev/null || echo "False")
        if [ "$status" = "True" ]; then
            echo_success "✓ Kubernetes realm import completed"
        else
            echo_error "✗ Kubernetes realm import not completed"
            validation_errors=$((validation_errors + 1))
        fi
    else
        echo_error "✗ Kubernetes realm import not found"
        validation_errors=$((validation_errors + 1))
    fi

    # Check routes/ingress
    if oc get route keycloak -n "$NAMESPACE" >/dev/null 2>&1; then
        echo_success "✓ Keycloak route exists"
    else
        echo_warning "⚠ Keycloak route not found (may be normal depending on ingress configuration)"
    fi

    if [ $validation_errors -eq 0 ]; then
        echo_success "All validation checks passed!"
        return 0
    else
        echo_error "$validation_errors validation error(s) found"
        return 1
    fi
}

# Function to configure security-admin-console client
# This fixes the admin console loading issue by adding proper Web Origins and Redirect URIs
configure_admin_console() {
    echo_header "CONFIGURING ADMIN CONSOLE"

    # Get Keycloak URL
    local KEYCLOAK_URL=$(oc get route keycloak -n "$NAMESPACE" -o jsonpath='{.spec.host}' 2>/dev/null || echo "")
    if [ -z "$KEYCLOAK_URL" ]; then
        echo_error "Could not get Keycloak route URL"
        return 1
    fi

    echo_info "Keycloak URL: https://$KEYCLOAK_URL"

    # Get admin credentials
    local ADMIN_PASSWORD=$(oc get secret keycloak-initial-admin -n "$NAMESPACE" -o jsonpath='{.data.password}' 2>/dev/null | base64 -d)
    if [ -z "$ADMIN_PASSWORD" ]; then
        echo_error "Could not retrieve admin password"
        return 1
    fi

    # Wait for Keycloak to be ready
    echo_info "Waiting for Keycloak admin API to be available..."
    local max_attempts=30
    local attempt=0
    local token_response=""

    while [ $attempt -lt $max_attempts ]; do
        token_response=$(curl -sk -X POST "https://$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=admin" \
            -d "password=$ADMIN_PASSWORD" \
            -d "grant_type=password" \
            -d "client_id=admin-cli" 2>/dev/null)

        local access_token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)

        if [ -n "$access_token" ]; then
            echo_success "✓ Admin API is available"
            break
        fi

        sleep 2
        attempt=$((attempt + 1))
    done

    if [ -z "$access_token" ]; then
        echo_error "Could not authenticate to Keycloak admin API"
        return 1
    fi

    # Get security-admin-console client ID
    echo_info "Configuring security-admin-console client..."
    local clients_response=$(curl -sk "https://$KEYCLOAK_URL/admin/realms/master/clients" \
        -H "Authorization: Bearer $access_token" 2>/dev/null)

    local client_uuid=$(echo "$clients_response" | grep -o '"id":"[^"]*","clientId":"security-admin-console"' | grep -o '"id":"[^"]*' | cut -d'"' -f4)

    if [ -z "$client_uuid" ]; then
        echo_error "Could not find security-admin-console client"
        return 1
    fi

    echo_info "Client UUID: $client_uuid"

    # Update client configuration to fix admin console loading issue
    # This adds explicit Web Origins and Redirect URIs
    local update_response=$(curl -sk -X PUT "https://$KEYCLOAK_URL/admin/realms/master/clients/$client_uuid" \
        -H "Authorization: Bearer $access_token" \
        -H "Content-Type: application/json" \
        -d '{
            "id": "'"$client_uuid"'",
            "clientId": "security-admin-console",
            "webOrigins": [
                "https://'"$KEYCLOAK_URL"'",
                "+"
            ],
            "redirectUris": [
                "https://'"$KEYCLOAK_URL"'/admin/master/console/*",
                "/admin/master/console/*"
            ]
        }' 2>/dev/null)

    # Verify the update
    local verify_response=$(curl -sk "https://$KEYCLOAK_URL/admin/realms/master/clients/$client_uuid" \
        -H "Authorization: Bearer $access_token" 2>/dev/null)

    if echo "$verify_response" | grep -q "https://$KEYCLOAK_URL"; then
        echo_success "✓ Admin console client configured successfully"
        echo_info "  - Web Origins: https://$KEYCLOAK_URL"
        echo_info "  - Redirect URIs: https://$KEYCLOAK_URL/admin/master/console/*"
    else
        echo_warning "Could not verify client configuration update"
    fi
}

# Function to extract and store client secret
extract_client_secret() {
    echo_header "EXTRACTING CLIENT SECRET"

    # Get Keycloak URL from Route
    local KEYCLOAK_URL=$(oc get route keycloak -n "$NAMESPACE" -o jsonpath='{.spec.host}' 2>/dev/null || echo "")
    if [ -z "$KEYCLOAK_URL" ]; then
        echo_warning "Could not determine Keycloak URL, skipping client secret extraction"
        return 1
    fi

    KEYCLOAK_URL="https://$KEYCLOAK_URL"
    echo_info "Keycloak URL: $KEYCLOAK_URL"

    # Get the admin password from the secret created by RHBK operator
    # The operator auto-generates a password and stores it in keycloak-initial-admin
    local ADMIN_PASSWORD=$(oc get secret keycloak-initial-admin -n "$NAMESPACE" -o jsonpath='{.data.password}' 2>/dev/null | base64 -d)

    if [ -z "$ADMIN_PASSWORD" ]; then
        echo_error "Could not retrieve auto-generated admin password from keycloak-initial-admin secret"
        echo_error "This secret should have been created by the RHBK operator"
        return 1
    fi

    echo_info "Using auto-generated admin password from RHBK operator"

    # Get admin token
    echo_info "Obtaining admin access token..."
    local TOKEN_RESPONSE=$(curl -sk -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=admin" \
        -d "password=$ADMIN_PASSWORD" \
        -d "grant_type=password" \
        -d "client_id=admin-cli" 2>/dev/null)

    local ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)

    if [ -z "$ACCESS_TOKEN" ]; then
        echo_warning "Could not obtain admin token, skipping client secret extraction"
        echo_info "You may need to manually retrieve the client secret from Keycloak admin console"
        echo_info "Token response: $TOKEN_RESPONSE"
        return 1
    fi

    echo_success "Admin token obtained"

    # Helper function to extract a client secret
    extract_single_client_secret() {
        local client_id=$1
        local secret_name=$2

        echo_info "Looking up client UUID for '$client_id'..."
        local CLIENT_DATA=$(curl -sk -X GET "$KEYCLOAK_URL/admin/realms/$REALM_NAME/clients" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" 2>/dev/null)

        local CLIENT_UUID=$(echo "$CLIENT_DATA" | grep -o "\"id\":\"[^\"]*\"[^}]*\"clientId\":\"$client_id\"" | grep -o "\"id\":\"[^\"]*\"" | cut -d'"' -f4 | head -1)

        if [ -z "$CLIENT_UUID" ]; then
            echo_warning "Could not find client '$client_id' in realm '$REALM_NAME'"
            return 1
        fi

        echo_success "Found client UUID: $CLIENT_UUID"

        # Get client secret
        echo_info "Retrieving client secret for '$client_id'..."
        local CLIENT_SECRET_RESPONSE=$(curl -sk -X GET "$KEYCLOAK_URL/admin/realms/$REALM_NAME/clients/$CLIENT_UUID/client-secret" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" 2>/dev/null)

        local CLIENT_SECRET=$(echo "$CLIENT_SECRET_RESPONSE" | grep -o '"value":"[^"]*' | cut -d'"' -f4)

        if [ -z "$CLIENT_SECRET" ]; then
            echo_warning "Could not retrieve client secret for '$client_id'"
            return 1
        fi

        echo_success "Client secret retrieved successfully for '$client_id'"

        # Create Kubernetes secret
        echo_info "Creating Kubernetes secret: $secret_name"
        oc create secret generic "$secret_name" \
            -n "$NAMESPACE" \
            --from-literal=CLIENT_ID="$client_id" \
            --from-literal=CLIENT_SECRET="$CLIENT_SECRET" \
            --dry-run=client -o yaml | oc apply -f - >/dev/null 2>&1

        if [ $? -eq 0 ]; then
            echo_success "Created secret: $secret_name"
            echo_info "  CLIENT_ID: $client_id"
            echo_info "  CLIENT_SECRET: [hidden - length ${#CLIENT_SECRET} chars]"
        else
            echo_warning "Failed to create secret: $secret_name"
            return 1
        fi
    }

    # Extract operator client secret
    extract_single_client_secret "$COST_MGMT_OPERATOR_CLIENT_ID" "keycloak-client-secret-cost-management-operator" || echo_warning "Failed to extract operator client secret"

    # Extract UI client secret
    extract_single_client_secret "$COST_MGMT_UI_CLIENT_ID" "keycloak-client-secret-cost-management-ui" || echo_warning "Failed to extract UI client secret"

    echo ""
}

# Function to create test user with org_id and account_number attributes
create_test_user() {
    echo_header "CREATING TEST USER"

    # Get Keycloak URL from Route
    local KEYCLOAK_URL=$(oc get route keycloak -n "$NAMESPACE" -o jsonpath='{.spec.host}' 2>/dev/null || echo "")
    if [ -z "$KEYCLOAK_URL" ]; then
        echo_warning "Could not determine Keycloak URL, skipping test user creation"
        return 1
    fi

    KEYCLOAK_URL="https://$KEYCLOAK_URL"
    echo_info "Keycloak URL: $KEYCLOAK_URL"

    # Get the admin password from the secret created by RHBK operator
    local ADMIN_PASSWORD=$(oc get secret keycloak-initial-admin -n "$NAMESPACE" -o jsonpath='{.data.password}' 2>/dev/null | base64 -d)

    if [ -z "$ADMIN_PASSWORD" ]; then
        echo_error "Could not retrieve auto-generated admin password from keycloak-initial-admin secret"
        return 1
    fi

    # Get admin token
    echo_info "Obtaining admin access token..."
    local TOKEN_RESPONSE=$(curl -sk -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=admin" \
        -d "password=$ADMIN_PASSWORD" \
        -d "grant_type=password" \
        -d "client_id=admin-cli" 2>/dev/null)

    local ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)

    if [ -z "$ACCESS_TOKEN" ]; then
        echo_warning "Could not obtain admin token, skipping test user creation"
        return 1
    fi

    echo_success "Admin token obtained"

    # Create test user with org_id and account_number attributes
    # These values match the operator client's hardcoded values for testing
    #
    # WORKAROUND: The org_id includes "org" prefix (org1234567 instead of 1234567)
    # because the Koku image has a bug that prepends "org" to the org_id when
    # creating tenant schemas. This results in schema names like "orgorg1234567"
    # when the org_id is "org1234567". Once the Koku bug is fixed, change this
    # back to a plain numeric org_id like "1234567".
    # See: https://github.com/project-koku/koku/issues/XXXX (TODO: add issue link)
    #
    # REQUIRED ATTRIBUTES for Cost Management:
    #   - org_id: Tenant identifier (maps to database schema)
    #   - account_number: Customer account identifier
    #
    # Note: "access" attribute is NOT required when using ENHANCED_ORG_ADMIN mode.
    # All authenticated users are treated as org admins with full access within their org.
    # This simplifies setup but means no granular RBAC within an org.
    # Multi-tenancy is preserved: users only see data for their own org_id.

    echo_info "Creating user 'test' with org_id and account_number attributes..."
    local USER_HTTP_CODE=$(curl -sk -o /tmp/user_response.txt -w "%{http_code}" -X POST "$KEYCLOAK_URL/admin/realms/$REALM_NAME/users" \
        -H "Authorization: Bearer $ACCESS_TOKEN" \
        -H "Content-Type: application/json" \
        -d "{
            \"username\": \"test\",
            \"email\": \"test@test.com\",
            \"emailVerified\": true,
            \"enabled\": true,
            \"firstName\": \"Test\",
            \"lastName\": \"User\",
            \"attributes\": {
                \"org_id\": [\"org1234567\"],
                \"account_number\": [\"7890123\"]
            }
        }" 2>/dev/null)

    local USER_RESPONSE=$(cat /tmp/user_response.txt 2>/dev/null || echo "")
    rm -f /tmp/user_response.txt

    local USER_ID=""
    if [ "$USER_HTTP_CODE" = "409" ] || echo "$USER_RESPONSE" | grep -q "already exists\|Conflict"; then
        echo_warning "User 'test' may already exist, attempting to find it..."
        # Get existing user
        local USERS_RESPONSE=$(curl -sk -X GET "$KEYCLOAK_URL/admin/realms/$REALM_NAME/users?username=test" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" 2>/dev/null)
        USER_ID=$(echo "$USERS_RESPONSE" | grep -o '"id":"[^"]*"' | cut -d'"' -f4 | head -1)

        if [ -n "$USER_ID" ]; then
            echo_info "Found existing user 'test', updating with attributes..."
            # Update user with attributes
            curl -sk -X PUT "$KEYCLOAK_URL/admin/realms/$REALM_NAME/users/$USER_ID" \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: application/json" \
                -d '{
                    "username": "test",
                    "email": "test@test.com",
                    "emailVerified": true,
                    "enabled": true,
                    "firstName": "Test",
                    "lastName": "User",
                    "attributes": {
                        "org_id": ["org1234567"],
                        "account_number": ["7890123"]
                    }
                }' >/dev/null 2>&1
            echo_success "✓ User 'test' updated"
        fi
    elif [ "$USER_HTTP_CODE" = "201" ] || [ "$USER_HTTP_CODE" = "200" ]; then
        # User created successfully, get ID from users list
        sleep 2
        local USERS_RESPONSE=$(curl -sk -X GET "$KEYCLOAK_URL/admin/realms/$REALM_NAME/users?username=test" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" 2>/dev/null)
        USER_ID=$(echo "$USERS_RESPONSE" | grep -o '"id":"[^"]*"' | cut -d'"' -f4 | head -1)
        echo_success "✓ User 'test' created"
    fi

    if [ -z "$USER_ID" ]; then
        echo_warning "Could not determine user ID for 'test'"
        return 1
    fi

    echo_info "User ID: $USER_ID"

    # Set user password
    echo_info "Setting password for user 'test'..."
    local PASSWORD_RESPONSE=$(curl -sk -X PUT "$KEYCLOAK_URL/admin/realms/$REALM_NAME/users/$USER_ID/reset-password" \
        -H "Authorization: Bearer $ACCESS_TOKEN" \
        -H "Content-Type: application/json" \
        -d '{
            "type": "password",
            "value": "test",
            "temporary": false
        }' 2>/dev/null)

    if [ $? -eq 0 ]; then
        echo_success "✓ Password set for user 'test'"
    else
        echo_warning "Could not set password for user 'test' (may already be set)"
    fi

    echo_success "✓ Test user creation complete"
    echo ""
}

# Function to display deployment summary
display_summary() {
    echo_header "DEPLOYMENT SUMMARY"

    # Get connection information
    local hostname=$(oc get keycloak keycloak -n "$NAMESPACE" -o jsonpath='{.status.hostname}' 2>/dev/null || echo "")
    local route_url=$(oc get route keycloak -n "$NAMESPACE" -o jsonpath='{.spec.host}' 2>/dev/null || echo "")

    # Use route URL if hostname is not available
    if [ -z "$hostname" ] && [ -n "$route_url" ]; then
        hostname="$route_url"
    fi

    if [ -z "$hostname" ]; then
        hostname="Not available"
    fi

    echo_info "Keycloak Deployment Information:"
    echo_info "  Operator: Red Hat Build of Keycloak (RHBK) v22+"
    echo_info "  API Version: k8s.keycloak.org/v2alpha1"
    echo_info "  Namespace: $NAMESPACE"
    echo_info "  Keycloak URL: https://$hostname"
    echo_info "  Realm: $REALM_NAME"
    echo_info "  Admin User: admin (auto-generated by operator)"
    echo ""

    echo_info "Cost Management Operator Client Information:"
    echo_info "  Client ID: $COST_MGMT_OPERATOR_CLIENT_ID"
    echo_info "  Client Type: Service Account (client_credentials flow)"
    echo_info "  Default Scopes: openid, profile, email, api.console"
    echo_info "  Note: api.console scope is defined at realm level"
    echo_info "  Secret stored in: keycloak-client-secret-cost-management-operator"
    echo ""

    echo_info "Cost Management UI Client Information:"
    echo_info "  Client ID: $COST_MGMT_UI_CLIENT_ID"
    echo_info "  Client Type: OAuth2 Public Client (authorization_code flow)"
    echo_info "  Redirect URI: ${UI_BASE_URL}/oauth2/callback"
    echo_info "  Web Origin: $UI_BASE_URL"
    echo_info "  Default Scopes: api.console, profile, email"
    echo_info "  Optional Scopes: offline_access"
    echo_info "  Secret stored in: keycloak-client-secret-cost-management-ui"
    echo ""

    echo_info "Test User Information:"
    echo_info "  User: test"
    echo_info "    Password: test"
    echo_info "    Email: test@test.com (verified)"
    echo_info "    Attributes:"
    echo_info "      org_id: org1234567 (includes 'org' prefix as workaround for Koku bug)"
    echo_info "      account_number: 7890123"
    echo_info "      access: OCP-only (openshift.cluster, openshift.project, openshift.node, cost_model)"
    echo ""

    # Display admin credential retrieval
    echo_info "To retrieve Keycloak admin credentials (auto-generated by RHBK operator):"
    echo_info "  oc get secret keycloak-initial-admin -n $NAMESPACE -o jsonpath='{.data.username}' | base64 -d"
    echo_info "  oc get secret keycloak-initial-admin -n $NAMESPACE -o jsonpath='{.data.password}' | base64 -d"
    echo ""

    echo_info "Next Steps:"
    echo_info "  1. Access Keycloak admin console at: https://$hostname"
    echo_info "  2. Test JWT token generation with: ./test-ocp-dataflow-jwt.sh"
    echo_info "  3. Configure your applications to use the JWT authentication"
    echo ""

    echo_success "RHBK/Keycloak deployment completed successfully!"
}

# Function to clean up (for troubleshooting)
cleanup_deployment() {
    echo_header "CLEANING UP DEPLOYMENT"
    echo_warning "This will remove all RHBK resources. Are you sure? (y/N)"
    read -r confirmation

    if [ "$confirmation" != "y" ] && [ "$confirmation" != "Y" ]; then
        echo_info "Cleanup cancelled"
        return 0
    fi

    echo_info "Removing RHBK resources..."

    # Remove realm imports
    oc delete keycloakrealmimport --all -n "$NAMESPACE" 2>/dev/null || true

    # Remove Keycloak instance
    oc delete keycloak --all -n "$NAMESPACE" 2>/dev/null || true

    # Remove secrets
    # Note: keycloak-initial-admin is managed by operator and will be auto-deleted
    oc delete secret keycloak-db-secret -n "$NAMESPACE" 2>/dev/null || true
    oc delete secret keycloak-client-secret-cost-management-operator -n "$NAMESPACE" 2>/dev/null || true
    oc delete secret keycloak-client-secret-cost-management-ui -n "$NAMESPACE" 2>/dev/null || true

    # Remove PVCs (if any were manually created in old versions)
    # Note: RHBK operator manages its own PVCs, they'll be deleted with the namespace
    oc delete pvc keycloak-data-pvc -n "$NAMESPACE" 2>/dev/null || true

    # Remove subscription
    oc delete subscription rhbk-operator -n "$NAMESPACE" 2>/dev/null || true

    # Remove operator group
    oc delete operatorgroup rhbk-operator-group -n "$NAMESPACE" 2>/dev/null || true

    # Remove namespace
    oc delete namespace "$NAMESPACE" 2>/dev/null || true

    echo_success "Cleanup completed"
}

# Main execution function
main() {
    echo_header "RED HAT BUILD OF KEYCLOAK (RHBK) DEPLOYMENT SCRIPT"
    echo_info "This script will deploy RHBK v22+ with Cost Management integration"
    echo_info "Using API version: k8s.keycloak.org/v2alpha1"
    echo_info ""
    echo_info "Configuration:"
    echo_info "  Namespace: $NAMESPACE"
    echo_info "  Storage Class: $STORAGE_CLASS"
    echo_info "  Realm: $REALM_NAME"
    echo_info "  Cost Management Operator Client ID: $COST_MGMT_OPERATOR_CLIENT_ID"
    echo_info "  Cost Management UI Client ID: $COST_MGMT_UI_CLIENT_ID"
    echo_info "  Keycloak Instances: $KEYCLOAK_INSTANCES"
    echo ""

    # Execute deployment steps
    check_prerequisites
    create_namespace
    install_rhbk_operator
    # Note: Admin secret is auto-generated by RHBK operator when Keycloak instance is created
    deploy_postgresql
    deploy_keycloak
    create_kubernetes_realm
    configure_admin_console
    extract_client_secret
    create_test_user

    # Validate and summarize
    if validate_deployment; then
        display_summary
    else
        echo_error "Deployment validation failed. Check the logs above for details."
        exit 1
    fi
}

# Handle script arguments
case "${1:-}" in
    "cleanup"|"clean")
        cleanup_deployment
        exit 0
        ;;
    "validate"|"check")
        validate_deployment
        exit $?
        ;;
    "help"|"-h"|"--help")
        echo "Usage: $0 [command]"
        echo ""
        echo "Commands:"
        echo "  (no command)    Deploy RHBK with all components"
        echo "  validate        Validate existing deployment"
        echo "  cleanup         Remove all RHBK resources"
        echo "  help            Show this help message"
        echo ""
        echo "Environment Variables:"
        echo "  RHBK_NAMESPACE            Target namespace (default: keycloak)"
        echo "  STORAGE_CLASS             Storage class name (auto-detected by default)"
        echo "  REALM_NAME                Realm name (default: kubernetes)"
        echo "  COST_MGMT_OPERATOR_CLIENT_ID  Operator client ID (default: cost-management-operator)"
        echo "  COST_MGMT_UI_CLIENT_ID    UI client ID (default: cost-management-ui)"
        echo "  COST_MGMT_NAMESPACE    UI namespace for URL construction (default: cost-onprem)"
        echo "  COST_MGMT_RELEASE_NAME UI release name for URL construction (default: cost-onprem)"
        echo "  COST_MGMT_UI_BASE_URL     UI base URL (auto-detected if not set)"
        echo "  KEYCLOAK_INSTANCES        Number of instances (default: 1)"
        echo ""
        echo "Note: Admin credentials are auto-generated by RHBK operator"
        echo "      Access them via: oc get secret keycloak-initial-admin -n keycloak"
        echo ""
        echo "Examples:"
        echo "  # Deploy with default settings"
        echo "  $0"
        echo ""
        echo "  # Deploy with custom storage class"
        echo "  STORAGE_CLASS=gp2 $0"
        echo ""
        echo "  # Deploy with HA configuration"
        echo "  KEYCLOAK_INSTANCES=2 $0"
        echo ""
        echo "  # Validate existing deployment"
        echo "  $0 validate"
        echo ""
        echo "  # Clean up deployment"
        echo "  $0 cleanup"
        echo ""
        echo "RHBK Operator Details:"
        echo "  This script uses the RHBK operator (k8s.keycloak.org/v2alpha1)"
        echo ""
        echo "  Key features:"
        echo "  - Uses KeycloakRealmImport instead of KeycloakRealm"
        echo "  - Clients are defined within the realm import"
        echo "  - Different CR structure for Keycloak instances"
        exit 0
        ;;
    "")
        main
        ;;
    *)
        echo_error "Unknown command: $1"
        echo_info "Use '$0 help' for usage information"
        exit 1
        ;;
esac

